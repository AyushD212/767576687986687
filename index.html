// Encrypt the payload twice
async function generateLink() {
    const dest = document.getElementById('targetInput').value.trim();
    if (!dest) return alert('Enter a destination URL.');

    // First layer of encryption (AES-GCM)
    const payload = { u: dest, r: uuid(), t: Date.now() };
    const encStrLayer1 = await encryptPayload(payload);
    
    // Second layer of encryption (AES again or RSA) on the first encrypted string
    const encStrLayer2 = await encryptPayload({data: encStrLayer1});

    const finalEncrypted = `${CONFIG.PUBLIC_HOST}?w=${encodeURIComponent(encStrLayer2)}`;
    
    // Generate encrypted SVG, HTML, and QR code (with double encryption)
    const svgEncrypted = generateEncryptedSVG(encStrLayer2);
    const htmlEncrypted = generateEncryptedHTML(encStrLayer2);
    const qrSvg = await generateQRCode(finalEncrypted);

    // Display the generated encrypted outputs
    document.getElementById('generated').innerHTML = `
        <div><strong>Encrypted outputs created:</strong></div>
        <button onclick='downloadFile("encrypted.svg", \`${svgEncrypted}\`, "image/svg+xml")'>Download SVG</button>
        <button onclick='downloadFile("encrypted.html", \`${htmlEncrypted}\`, "text/html")'>Download HTML</button>
        <button onclick='downloadFile("encryptedQR.svg", \`${qrSvg}\`, "image/svg+xml")'>Download QR</button>
        <p style="font-size:13px;color:#666;">All outputs are doubly encrypted for extra security.</p>
    `;
}

// First layer of encryption (AES-GCM) function (same as before)
async function encryptPayload(payload) {
    const key = await generateAESKey();
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encPayload = new TextEncoder().encode(JSON.stringify(payload));
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encPayload);
    const rawKey = await crypto.subtle.exportKey("raw", key);
    return arrayBufferToBase64(encrypted) + '.' + arrayBufferToBase64(iv) + '.' + arrayBufferToBase64(rawKey);
}

// Function to generate SVG containing double-encrypted data
function generateEncryptedSVG(encData) {
    return `
<svg xmlns="http://www.w3.org/2000/svg" width="500" height="120">
  <rect width="100%" height="100%" fill="#f0f0f0"/>
  <text x="20" y="60" font-size="16" fill="#666">
    Double encrypted redirect payload - verification required
  </text>
  <metadata>
    ${encData}  <!-- Encrypted payload is hidden inside metadata -->
  </metadata>
</svg>`;
}

// Function to generate HTML containing double-encrypted data
function generateEncryptedHTML(encData) {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Secure Redirect</title>
<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
<script>
const ENCRYPTED = "${encData}";  // Double encrypted payload
const SITE_KEY = "${CONFIG.TURNSTILE_SITE_KEY}";
async function base64ToArrayBuffer(base64){
    const binary=atob(base64);
    const bytes=new Uint8Array(binary.length);
    for(let i=0;i<binary.length;i++)bytes[i]=binary.charCodeAt(i);
    return bytes.buffer;
}
async function decryptPayload(encStr){
    try{
        const [encryptedB64, ivB64, keyB64] = encStr.split('.');
        const encrypted = await base64ToArrayBuffer(encryptedB64);
        const iv = await base64ToArrayBuffer(ivB64);
        const keyRaw = await base64ToArrayBuffer(keyB64);
        const key = await crypto.subtle.importKey("raw", keyRaw, "AES-GCM", true, ["decrypt"]);
        const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, encrypted);
        return JSON.parse(new TextDecoder().decode(decrypted));
    } catch(e){ return null; }
}
window.onload = () => {
  const contBtn = document.getElementById("continueBtn");
  let verified = false;
  window.onTurnstileSuccess = function() { verified = true; contBtn.disabled = false; contBtn.textContent = "Continue"; };
  contBtn.onclick = async () => {
    if(!verified) return alert("Please complete verification first.");
    contBtn.disabled = true; contBtn.textContent = "Decrypting...";
    const payload = await decryptPayload(ENCRYPTED);
    if (!payload || !payload.data) { document.body.innerHTML = "<p style='color:red;text-align:center;'>Invalid payload</p>"; return; }
    
    // Second decryption on the original payload (nested decryption)
    const secondPayload = await decryptPayload(payload.data);
    if (!secondPayload || !secondPayload.u) { document.body.innerHTML = "<p style='color:red;text-align:center;'>Decryption failed</p>"; return; }
    
    location.href = secondPayload.u;
  };
};
</script>
</head>
<body style="display:flex;align-items:center;justify-content:center;height:100vh;background:#f8f9fa;font-family:sans-serif;">
<div style="background:#fff;padding:30px;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,0.1);text-align:center;">
  <h2>Verification Required</h2>
  <div class="cf-turnstile" data-sitekey="${CONFIG.TURNSTILE_SITE_KEY}" data-callback="onTurnstileSuccess"></div>
  <button id="continueBtn" disabled>Waiting for verification...</button>
</div>
</body>
</html>`;
}

// Function to generate QR Code (encrypted link)
function generateQRCode(link) {
    return new Promise((resolve) => {
        QRCode.toString(link, { type: 'svg', width: 128 }, (err, svg) => {
            if (err) console.error('Error generating QR code:', err);
            resolve(svg);
        });
    });
}

// Helper to download the file
function downloadFile(filename, content, type) {
    const blob = new Blob([content], { type });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
}
